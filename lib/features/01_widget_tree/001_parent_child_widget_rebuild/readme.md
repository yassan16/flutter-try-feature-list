# 親・子Widget間の再ビルド
前提：再描画の仕組み 
* setState(() {}) を呼ぶと、Flutterは build() を再実行します。
* 再描画されるのはそのウィジェットと配下の子ウィジェットだけです。
* 親ウィジェットに影響はありません。


## 疑問：子ウィジェットが build を持っている場合は？
### 回答
子ウィジェットが別クラスとして StatelessWidget や StatefulWidget に分かれている場合、その親ウィジェットの build() が再実行されると、Flutterは子ウィジェットのインスタンスが「変わっていないか」を比較してから再描画の判断をします。

### 具体的にいうと：
✅ 子ウィジェットが「新しいインスタンスに置き換えられた」場合：
→ その子も再ビルドされる。

❌ 子ウィジェットが「以前と同じインスタンス（もしくは同じ Key）」の場合：
→ Flutterは賢く「再ビルドしない」ようにします。

### 🧠 Flutterのビルドの仕組みの概要
1. setState()が呼ばれると、親の build() が呼ばれる。
2. build() の中で、子ウィジェットが生成される。
3. Flutter は「前回のウィジェットツリー」と「今回のウィジェットツリー」を比較（diff）。
4. 「変わったウィジェット」だけを再描画する。

### 🔁 再描画の判断基準
* StatelessWidget や StatefulWidget は、== で比較されて違えば再描画。
* Key を付けておくことで、「別のインスタンスでも同じもの」として扱ってくれる。

### ✅ 結論まとめ
| 状況 | 子の build() は？ |
| ---- | ---- |
| 親で setState() を呼び、子を再生成する | 再ビルドされる |
| 子を const で定義 | 再ビルドされない |
| 子に Key をつけて Flutter に「同じ」と教える | 再ビルドされない |
| 子が Provider 等で独自に watch している	 | 自分の判断で再ビルド |

### 実行ログ
```
flutter: ParentWidget build
flutter: ChildWidget build
(2つ目の子widetのログはなし)
```

## そもそもウィジェットツリー🌳とは？
### 🔷 一言でいうと：
Flutter アプリの UI を構成する「部品の階層構造」です。

### 📐 具体的にどういうもの？
Flutter では、画面に表示されるあらゆるもの（テキスト、ボタン、余白など）を **「ウィジェット」**という最小単位で作ります。

それらのウィジェットは、親子関係でつながれていて、
入れ子（ネスト）構造の「木（ツリー）」のように構築されます。

###📦 例で理解
次のコードを見てください：

```dart
@override
Widget build(BuildContext context) {
  return Scaffold(
    appBar: AppBar(
      title: Text('Hello'),
    ),
    body: Center(
      child: Column(
        children: [
          Text('Welcome'),
          ElevatedButton(
            onPressed: () {},
            child: Text('Tap me'),
          ),
        ],
      ),
    ),
  );
}
```
これをツリー状に書き起こすと：

```scss
Scaffold
├── AppBar
│   └── Text('Hello')
└── Center
    └── Column
        ├── Text('Welcome')
        └── ElevatedButton
            └── Text('Tap me')
```
このように、すべての UI がツリー構造でつながっています。
Scaffold が最上位の親で、その中に AppBar や Body、さらにその中に Column、さらにその中に…と続きます。

### 🔁 これがなぜ重要？
1. 再描画（再build）の単位になるから
    * ツリー構造により、「どこが変わったのか」を Flutter が判定しやすい
    * 変更があった部分とその子だけが再描画される
    * パフォーマンスに大きく関係
2. UIの構造を明確に理解できる
    * ネスト（入れ子）構造で UI を分割・整理できる
3. 状態管理との連携
    * Riverpodなどで watch された値が更新されると、そのウィジェットツリーの該当部分だけが再構築される

### 🧠 補足：3つのツリーがある
Flutterの内部的には、以下の3種類のツリーが連動しています：
| 名前 | 説明 |
| ---- | ---- |
| ウィジェットツリー | ユーザーが書く、UIの宣言 |
| エレメントツリー | 実行時に構築される実体。状態などを保持する |
| レンダーツリー | 実際に画面に描画されるレイアウト情報のツリー |

初心者は「ウィジェットツリー」だけ意識していれば十分です。

### ✅ まとめ
* ウィジェットツリーは Flutter アプリの UI の構造そのもの
* 親子関係をもったツリー構造
* 再描画や状態管理、パフォーマンスにも関わる
* コードをツリー構造として理解することで、アプリの全体像がつかみやすくなる


